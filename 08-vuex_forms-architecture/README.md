# vuex+forms; Архитектура

## Vuex + Forms

Ссылки:
- Раздел документации о работе с формами: [https://vuex.vuejs.org/guide/forms.html](https://vuex.vuejs.org/guide/forms.html).
- Библиотека vuex-persist для сохранения и восстановления хранилища: [https://github.com/championswimmer/vuex-persist](https://github.com/championswimmer/vuex-persist).

## Структура приложения

Чтобы с кодом приложения было удобно работать, его требуется организовать. (Не путать с архитектурой).

Организация файлов не влияет на то, как приложение функционирует, но может помочь быстрее в нём ориентироваться разработчику.

Самый простой и популярный вариант разделения -- так называемый feature-based подход, при котором модули приложения разделяются своим по задачам, которые они решают.

Мы уже знакомы с директориями `router` с файлами роутера, `store` с файлами хранилища. Такие же директории появляются для других элементов Vue: `directives`, `plugins`, `mixins` и т.д.

Большая часть модулей приложения -- это компоненты. Мы уже начали их разделять их на две большие группы -- `views` и `components`. Последнее можно продолжать разделять:
- `ui` - UI компоненты, глупые компоненты интерфейса (кнопки, карточки и т.д.);
- `layout` - компоненты, основные части шаблона приложения (шапка, подвал, главное меню);
- `layouts` - шаблоны страниц.

Компоненты, использование которых подразумевается, как единое целое в определённое структуре, также можно хранить вместе.

```
├───public
└───src
    ├───api
    ├───assets
    ├───components
    │   ├───layout
    │   ├───layouts
    │   ├───MeetupPage
    │   ├───MeetupsPage
    │   └───ui
    │       ├───buttons
    │       ├───forms
    │       └───transitions
    ├───config
    ├───directives
    ├───emitters
    ├───mixins
    ├───plugins
    ├───router
    ├───services
    ├───store
    │   └───modules
    ├───utils
    └───views
        └───MeetupPage
```

Другой подход -- разделение модулей приложения не по функциям, а по домену, по предметной области (domain-based, domain-driven). 

При разделении по функциям связные части приложения разбросаны по проекту. Части приложения, связанная с авторизацией и регистрацией, будет иметь несколько роутов в роутере, один модуль в `store`, и пару страниц во `views` и несколько компонентов `components`.

Вместо этого предлагается разделить приложения на модули, каждый из которых будет решать определённую бизнес задачу, а структура модуля совпадает с feature-based подходом.

```
├───public
└───src
    ├───Common
    │   ├───utils
    │   ├───components
    │   │   └───ui
    ├───Meetups
    │   ├───api
    │   ├───assets
    │   ├───components
    │   ├───routes
    │   ├───services
    │   ├───store
    │   └───views
    ├───Auth
    │   ├───api
    │   ├───assets
    │   ├───components
    │   ├───routes
    │   ├───services
    │   ├───store
    │   └───views
    ├───Admin
    │   ├───api
    │   ├───assets
    │   ├───components
    │   ├───routes
    │   ├───services
    │   ├───store
    │   └───views
```

Однако для удобного использования такой подход потребует создания некоторой системы регистрации модулей.

*Примечание: это всего лишь некоторые варианты структур. Vue.js почти никак не определяет за нас структуру, а подходы могут быть разные в разных компаниях.*

## Архитектура приложения

Vue.js практически не определяет архитектуру приложения. Проектирование архитектуры приложения -- сложная сфера, изучение которой, возможно, больше (и сложнее), чем изучение Vue.js.

Главное - сделать приложение расширяемым, поддерживаемым, тестируемым, переиспользуемым. 

Первое, что требуется сделать -- избавиться от дублирования кода. Это касается и компонентов, и других модулей приложения.

Второе -- определить слои приложения, каждое из которых отвечает за определённый уровень абстракции. Vue компонент не должен думать о том, по какому API URL получить нужные данные, как отправлять запрос, с какими заголовками, как обрабатывать все возможные ответы и т.д. 

Один из предлагаемых вариантов архитектуры -- выделить следующие слои:
- HTTP Client - слой (или библиотека), создающая абстракцию над BOM для упрощения работы с xhr / fetch. Например, [axios](https://github.com/axios/axios) или [got](https://github.com/sindresorhus/got);
- Экземпляр HTTP клиента, с определёнными установленными настройками, заголовками, или интерсепторами (функциями, выполняющимися для каждого запроса);
- API слой - модуль, хранящий методы взаимодействия с API определённого ресурса или предметной области;
- Service слой - слой, содержащий всё, что необходимо для работы с определённым ресурсом или предметной областью, не зависимо от UI компонентов. 

API слой можно объединить с Service слоем. А можно усложнить архитектуру:
- Добавить классы сущностей;
- Добавить DTO (Data Transfer Object) классы (или интерфейсы), определяющие форматы, контракты, связанные с API;
- Вместо прямого импорта зависимостей применять Dependency Injection или Service Provider для реализации принципа инверсии зависимостей;
- и т.п.

При улучшении архитектуры объём кода, сложность абстракций могут значительно увеличиваться в сравнении с простыми решениями. Важно найти минимальную архитектурную сложность, которая будет удовлетворять требования приложения (и бизнеса), не создавая переусложнения.

Ссылки:
- https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)
- https://ota-solid.now.sh/
- Предметно-ориентированное проектирование (DDD): [https://ru.wikipedia.org/wiki/Предметно-ориентированное_проектирование](https://ru.wikipedia.org/wiki/Предметно-ориентированное_проектирование);
- Классный сайт (и не только) о рефакторинге и паттернах проектирования с примерами на JavaScript: [https://refactoring.guru/](https://refactoring.guru/);
- [Роберт Мартин | Чистый код: создание, анализ и рефакторинг](https://www.piter.com/collection/A27-854/product/chistyy-kod-sozdanie-analiz-i-refaktoring-biblioteka-programmista-45ccca);
- [Роберт Мартин | Чистая архитектура. Искусство разработки программного обеспечения](https://www.piter.com/product/chistaya-arhitektura-iskusstvo-razrabotki-programmnogo-obespecheniya);
- Markus Oberlehner | Dependency Injection in Vue.js Applications: [https://markus.oberlehner.net/blog/dependency-injection-in-vue-applications/](https://markus.oberlehner.net/blog/dependency-injection-in-vue-applications/).

## Scoped Slots

Обычные слоты позволяют передать содержимое от родителя в дочерний компонент. Это простой инструмент, позволяющий создавать компоненты с различным содержимым.

Scoped Slot (Слоты с ограниченной областью видимости) - это инструмент, позволяющий не просто передать содержимое от родительского компонента дочернему, а передать шаблон (рендер функцию), у которого будет доступ к ограниченной области дочернего компонента.

Хотя это похожий инструмент, он решает совершенно другие задачи и работает иначе.

Дочерний компонент определяет положение слота, содержимое по умолчанию и (новое) связывает слот со своими данными (или методами) через **параметры слота**.

```vue
<!-- Дочерний компонент с scoped slot -->
<slot 
  name="slot1" 
  :itemFromData="itemFromData" 
  :computedFirstItem="computedFirstItem" 
  :updateItemMethod="updateItemMethod"
><!-- default --></slot>

<!-- Работает как обычно с v-bind -->
<slot v-bind="{ itemFromData, computedFirstItem, updateItemMethod }"><!-- default --></slot>
```

Родительский компонент определяет шаблон (рендер функцию) слота в качестве параметра получая объект с параметрами слота.

```vue
<!-- Родительский компонент -->
<template #slot1="scope">
  <button @click="scope.updateItemMethod('newValue')">{{ scope.itemFromData }}</button>
</template>

<!-- Работает деструктуризация -->
<template #default="{ updateItemMethod, itemFromData }">
  <button @click="updateItemMethod('newValue')">{{ itemFromData }}</button>
</template>

<!-- Самый короткий вариант для слота по умолчанию -->
<template v-slot="{ updateItemMethod, itemFromData }">
  <button @click="updateItemMethod('newValue')">{{ itemFromData }}</button>
</template>
```

Scoped Slots позволяют инкапсулировать логику в дочернем компоненте, отдавая родительскому компоненту возможность определять шаблон. 

Это мощный инструмент создания кастомизируемых, переиспользуемых компонентов и реализации принципе инверсии зависимостей в отношении компонентов.

Важное отличие scoped slots от обычных слотов -- они не передаются через несколько компонентов.

Документация: [https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots](https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots).

## Renderless Component

Дословно "компонент без рендеринга". Некоторый компонент, инкапсулирующий в себе только логику, но не имеющий своего отображения.

Через такой компонент можно описывать разный шаблон или создавать простые компоненты обёртки, которые реализуют UI для переиспользуемой логики.

Реализация за счёт scoped slots.

Простейший вариант - просто срендерить scoped slot рендер функцией:

```vue
<script>
export default {
  // Какая-то логика (data, computed, methods ...)

  // Вместо шаблона можно использовать рендер функцию
  render(h) {
    // $scopedSlots - объект со всеми scoped слотами
    // Каждый такой слот -- это рендер функция, принимающая на вход параметры слота, его область видимости
    // default -- слот по умолчанию 
    // в слот передаются все параметры (данные и методы), которые необходимы для реализации интерфейса 
    return this.$scopedSlots.default({
      someData: this.someData,
      someMethod: this.someMethod,
    });
  },
}
</script>
```

В этом случае мы получаем компонент, у которого вообще нет своего содержимого, даже обёртки. Аналог на шаблоне не сделать, так как `<slot>` не может быть корневым элементом в шаблоне.

Однако мы можем захотеть использовать несколько компонентов (элементов) для реализации UI. В этом случае мы получим ошибку, так как нельзя в рендер функции вернуть несколько элементов (должен быть ровно один корневой элемент). 

Простое решение -- либо отправить в слот содержимое, обернутое в элемент (например, `span`), либо создать отдельный компонент.

Если всё-таки хочется гарантированно избавиться от такой проблемы, можно сразу добавить обёртку в самом Renderless компоненте. В этом случае будет рендериться "лишний" элемент обёртка.

```vue
<template>
  <!-- Теперь можно использовать шаблон -->
  <component :is="tag">
    <slot v-bind="{ someData }" />
  </component>
</template>

<script>
export default {
  // Какая-то логика
  // Добавим параметр для выбора элемент обёртки (по умолчанию span)
  props: {
    tag: {
      default: 'span',
    },
  },
  // Либо также рендер функцией
  // В которой можно посчитать детей и решить, нужна ли обёртка
  render(h) {
    const content = this.$scopedSlots.default({
      someData: this.someData,
      someMethod: this.someMethod,
    });
    return content.length > 1 ? h(this.tag, content) : content[0];
  }
}
</script>
```

Ссылки:
- Классическая статья про Renderless компоненты во Vue, **Adam Wathan | Renderless Components in Vue.js**:
[https://adamwathan.me/renderless-components-in-vuejs/](https://adamwathan.me/renderless-components-in-vuejs/)
- Интересный пример использования Renderless компонента для работы с API, **Markus Oberlehner | Reusing Logic With Renderless Vue.js Frame Components**:
[https://markus.oberlehner.net/blog/reusing-logic-with-renderless-vue-frame-components/](https://markus.oberlehner.net/blog/reusing-logic-with-renderless-vue-frame-components/)

## Container + Presentational Component

Существует подход, в котором вместо того, чтобы делать компонент, занимающийся и работой с данными, и их отображением, предлагается разделить его на два: компонент-контейнер и компонент-представление.

Компонент представление ("Presentational Component", "Глупый Компонент", "Dummy Component") определяет, как нечто выглядит. Слабо связан, не занимается получением, хранением или обработкой данных сам, а лишь отображает переданные ему данные и сообщает о действиях пользователя.

Компонент контейнер ("Container Component", "Умный компонент", "Smart Component") определяет работу с данными, логику и предоставляет это компоненту представления.

Такое разделение позволяет сделать компоненты более универсальными, тестируемыми, ограничить их область ответственности.  

Простой вариант реализации - явное разделение и использование "глупого" компонента внутри "умного". В более сложном случае можно использовать scoped slots и Renderless компоненты.

Чрезмерное разделение на "умные" и "глупые" компоненты может значительно усложнить разработку без большого профита.

Ссылки:
- Dan Abramov | Presentational and Container Components: [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).
- Markus Oberlehner | Container Components in Vue.js: Advanced Component Composition: [https://markus.oberlehner.net/blog/advanced-vue-component-composition-with-container-components/](https://markus.oberlehner.net/blog/advanced-vue-component-composition-with-container-components/)

## Higher-Order Component

Higher-Order Component (HOC) - компонент высшего порядка.

Функция, которая принимает на вход компонент (и, возможно, другие параметры), а возвращает новый компонент.

В отличие от обычного компонента обёртки, позволяет создавать множество новых компонентов над старыми.

Описание концепции в документации React.js: [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html).

*Подход во Vue.js встречается довольно редко, но может помочь вам решить некоторые задачи.*
