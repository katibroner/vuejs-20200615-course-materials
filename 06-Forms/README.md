# Формы

Во Vue.js легко и удобно работать с формами. Директива `v-model` позволяет легко делать двустороннее связывание, синхронизировать значение поля формы и состояния компонента.

Но всё становится несколько сложнее, когда мы разрабатываем компоненты-формы, особенно, если это форма "редактирования объекта". 

Кратко, о чём требуется помнить

## One-way data flow

От родителя дочернему компоненту данные передаются через параметры. От дочернего компонента родительскому -- вместе с событиями.

Если параметр -- мутируемый объект, то использование его свойств в v-model (или другое изменение) -- приведёт к мутации параметра и нарушении one-way data flow.

Хотя, это самый простой и дешёвый способ сделать компонент-форму.

## Работа с локальным состоянием

Первым делом, чтобы избавиться от мутации параметра, требуется добавить локальное состояние, которое будет инициализироваться по значению параметра.

## Возврат результата родителю

Проще всего, и не редко достаточно, отправлять результат по окончанию работы с формой, например, по `submit`.

Если результат нужен в процессе редактирования формы, то можно порождать событие с новым значением по `change` или `input` полей формы, а также при других изменениях.

## Отслеживание локального состояния

Добавлять на все поля формы обработчик события изменения и помнить, что данные могут измениться не только на полях формы -- трудоёмко.

Тут можно вспомнить об отслеживании (`watch`), и что с параметром `deep: true` он позволяет выполнять какую-либо функцию при обновлении локального состояния. 

## Отслеживание входного параметра

Может потребоваться не только уведомлять родителя об обновлении данных формы, но и обновлять форму при изменении параметра родителем. Само по себе обновление работать не будет, ведь теперь входной параметр используется только при инициализации, а дальше работает локальное состояние.

Здесь также поможет отслеживание через `watch`. Но, если на локальном состоянии стоит отслеживание с порождением события обновления, которое (например, с `v-model` или `sync`), обновляет параметр, который отслеживается для обновления локального состояния -- получится бесконечный цикл.

Чтобы это предотвратить, потребуется в одном из отслеживаний проверять, действительно ли изменилось значение.

## Про клонирование и сравнение объектов

Требуется не забывать, что объекты -- мутируемые ссылочные типы. Это значит, что: 
- При сравнении объектов сравнивается ссылка, а не значение;
- При присваивании объекта присваивается ссылка, а не создаётся копия;

Простые объекты (значения свойств которого -- примитивные типы) можно клонировать с помощью `Object.assign` или `spread` оператора (`...`). Для сложных объектов потребуется использовать более сложные функции или специальные библиотеки. Делать это желательно в обе стороны (и при клонировании входного параметра, и при порождении события с результатом) для предотвращения случайной мутации.

Так как входной параметр и локальное значение теперь клонируются, сравнивать их явно нельзя (ссылки разные). Потребуется более сложное сравнение по значению свойств объектов или специальные библиотеки.

P.S. пока не принят [proposal-record-tuple](https://github.com/tc39/proposal-record-tuple).

## Выбор оптимального решения

Не требуется всегда выбирать самое "мощное решение", ведь оно и более трудозатратное, и более ресурсоёмкое (клонирование). В каждой задаче лучше выбирать минимальный оптимальный вариант. 

Кроме того, есть и другие инструменты в разработке компонентов, которые будут изучены позже, например, `provide/inject` и `store, vuex`.
